import torch
import random

from torch.utils.data import Dataset, DataLoader


class EdgeDataset(Dataset):
    """
    EdgeDataset with negative sampling.

    This dataset returns tuples representing a single graph edge together
    with a set of negative samples generated by corrupting the destination
    node. Each returned element has the following structure:

    ``(src_emb, rel_id, dst_emb, label)``

    * ``src_emb`` – torch.Tensor containing the embedding of the source
      node.
    * ``rel_id`` – integer index corresponding to the relation type.
    * ``dst_emb`` – torch.Tensor containing the embedding of the destination
      node (or a corrupted node for negative samples).
    * ``label`` – ``1.0`` for a true edge and ``0.0`` for a negative
      sample.

    Negative samples are created by randomly selecting a node from
    ``all_node_ids`` (excluding the original destination node) for each
    positive edge.  The number of negative samples per positive edge is
    controlled by ``num_neg``.

    Parameters
    ----------
    edge_index : list[tuple[int, int, str]]
        List of edges in the form (source_id, destination_id, relation_type).
    node2emb : dict[int, torch.Tensor]
        Mapping from node identifiers to their embedding tensors.
    rel2idx : dict[str, int]
        Mapping from relation type strings to integer indices.
    num_neg : int, default 1
        Number of negative samples to generate per positive edge.
    all_node_ids : list[int] | None, default None
        Optional list of all node identifiers. If omitted, it will be
        inferred from ``node2emb``.

    Notes
    -----
    The dataset is intended for use with a PyTorch DataLoader where the
    returned tuples will be collated into batches.
    """

    def __init__(
        self,
        edge_index: list[tuple[int, int, str]],
        node2emb: dict[int, torch.Tensor],
        rel2idx: dict[str, int],
        num_neg: int = 1,
        all_node_ids: list[int] | None = None,
    ):
        self.edges = edge_index
        self.node2emb = node2emb
        self.rel2idx = rel2idx
        self.num_neg = num_neg
        self.all_node_ids = (
            all_node_ids if all_node_ids is not None else list(node2emb.keys())
        )
        self.rel_cnt = len(rel2idx)

    def __len__(self):
        return len(self.edges)

    def __getitem__(self, idx):
        """
        Retrieve a positive-edge sample and generated negative samples.

        Parameters
        ----------
        idx : int
            Index of the edge in the dataset.

        Returns
        -------
        tuple
            A tuple where the first element is a tuple representing the
            positive sample ``(src_emb, rel_id, dst_emb, torch.tensor(1.0))``
            and the following elements are tuples for each negative sample
            ``(src_emb, rel_id, corrupt_dst_emb, torch.tensor(0.0))``.
        """
        src, dst, rel = self.edges[idx]
        rel_id = self.rel2idx[rel] if isinstance(rel, str) else int(rel)

        # Positive example (rel_id as a long tensor with shape[1])
        pos = (
            torch.tensor([src], dtype=torch.long),
            torch.tensor([rel_id], dtype=torch.long),
            torch.tensor([dst], dtype=torch.long),
            torch.tensor(1.0),
        )

        # Negative examples (corrupted destination)
        neg = []
        for _ in range(self.num_neg):
            # randomly pick a different destination node
            corrupt_dst = random.choice(self.all_node_ids)
            while corrupt_dst == dst:
                corrupt_dst = random.choice(self.all_node_ids)
            neg.append(
                (
                    torch.tensor([src], dtype=torch.long),
                    torch.tensor([rel_id], dtype=torch.long),
                    torch.tensor([corrupt_dst], dtype=torch.long),
                    torch.tensor(0.0),
                )
            )

        return pos, *neg
